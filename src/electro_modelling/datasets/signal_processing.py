# -*- coding: utf-8 -*-

"""
Module that defines the SignalOperator class to process
audio signal
TODO: TO COMPLETE
"""

import numpy as np
import librosa


class SignalOperators:
    """
    TODO: Class description

    Parameters
    ----------
    nfft : int
        default is 1024
    nmels : int

    sr :

    ntimes :

    signal_length :

    phase_rec_method :

    v_max :

    v_min :

    Attributes
    ----------

    """

    def __init__(
        self,
        nfft=1024,
        nmels=512,
        sr=16000,
        ntimes=128,
        signal_length=32000,
        phase_rec_method="Griffin-Lim",
        v_max=2.2926,
        v_min=-6.0,
    ):
        # Parameters for the STFT analysis and synthesis
        self.ntimes = ntimes
        self.nfft = nfft
        self.nfft2 = int(nfft / 2 + 1)
        self.hop = int(self.nfft / 4)
        self.win_length = self.nfft
        self.sr = sr
        self.signal_length = signal_length
        self.nb_trames = int((self.signal_length - self.win_length) / self.hop)
        self.v_min = v_min
        self.v_max = v_max
        # Parameters for the MEL spectrograms
        self.nmels = nmels
        self.freqs = np.linspace(0, self.sr / 2, self.nfft2)
        self.times = np.linspace(
            0, self.signal_length / self.sr * self.ntimes / self.nb_trames, self.ntimes
        )
        self.mel_freqs = librosa.mel_frequencies(
            n_mels=self.nmels, fmin=0.0, fmax=sr / 2, htk=True
        )
        self.mel_fbank = librosa.filters.mel(
            sr=self.sr,
            n_fft=self.nfft,
            n_mels=self.nmels,
            fmin=0,
            fmax=self.sr / 2,
            htk=True,
            norm=False,
        )
        # TODO : check if use of transpose or Moore pseudo inverse
        # self.inverse_fbank = self.mel_fbank.transpose()
        self.inverse_fbank = np.linalg.pinv(self.mel_fbank)

        # Phase reconstruction method
        self.phase_rec_method = phase_rec_method

        # If the chosen phase reconstruction method is the Griffin-Lim
        # algorithm, needed parameters
        if self.phase_rec_method == "Griffin-Lim":
            self.griffin_phase_init = None
            self.griffin_nb_iterations = 50
            self.griffin_required_loss = False

    def normalize_spectrogram(self, STFT_amp):
        """

        Parameters
        ----------
        STFT_amp

        Returns
        -------

        """
        return (STFT_amp - 0.5 * (self.v_max + self.v_min)) / (
            0.5 * abs(self.v_max - self.v_min)
        )

    def unnormalize_spectrogram(self, STFT_amp_norm):
        """

        Parameters
        ----------
        STFT_amp_norm

        Returns
        -------

        """
        return STFT_amp_norm * (0.5 * abs(self.v_max - self.v_min)) + 0.5 * (
            self.v_max + self.v_min
        )

    def forward(self, signal, normalize=False):
        """

        Parameters
        ----------
        signal
        normalize

        Returns
        -------

        """
        STFT = self.get_stft(signal)
        STFT_mel = self.stft_to_mel(STFT)
        if normalize:
            STFT_mel[0] = self.normalize_spectrogram(STFT_mel[0])
        return STFT_mel

    def backward(self, STFT_mel, unnormalize=False):
        """

        Parameters
        ----------
        STFT_mel
        unnormalize

        Returns
        -------

        """
        if (
            self.phase_rec_method == "Griffin-Lim"
        ):  # Use the Griffin-Lim algorithm to reconstruct the phase
            # from a STFT amplitude
            if unnormalize:
                STFT_mel[0] = self.unnormalize_spectrogram(STFT_mel[0])
            STFT_mel_amp_log = STFT_mel[0]
            STFT_mel_amp = 10 ** (STFT_mel_amp_log)
            STFT_amp = self.mel_to_stft_griffin(STFT_mel_amp)
            STFT_phase = self.griffin_phase(STFT_amp)
        elif (
            self.phase_rec_method == "IF"
        ):  # Use the instantaneous frequencies generated by
            # the network to reconstruct the phase
            STFT_amp, STFT_IF = self.mel_to_stft_IF(STFT_mel)
            STFT_phase = self.get_phase_from_if(STFT_IF)
        else:
            raise AssertionError(
                "This phase reconstruction method " "is not implemented."
            )
        STFT = STFT_amp * np.exp(1j * STFT_phase)
        signal = self.rebuild_signal(STFT)
        signal = signal / np.max(abs(signal))
        return signal

    def get_IF_from_phase(self, phase):
        """

        Parameters
        ----------
        phase

        Returns
        -------

        """
        unwrapped_phase = np.unwrap(phase, axis=1)
        IF = np.pad(np.diff(unwrapped_phase, axis=1) / np.pi, ([0, 0], [1, 0]))
        return IF

    def get_phase_from_if(self, IF):
        """

        Parameters
        ----------
        IF

        Returns
        -------

        """
        return np.cumsum(IF * np.pi, axis=1)

    def get_stft(self, signal, pad=True):
        """

        Parameters
        ----------
        signal
        pad

        Returns
        -------

        """
        current_nb_trames = int((signal.shape[0] - self.win_length) / self.hop)
        STFT = np.zeros((self.nfft2, current_nb_trames), dtype="complex")
        for j in range(self.nb_trames):
            i0 = j * self.hop
            iend = min(i0 + self.win_length, signal.size)
            signal_w = signal[i0:iend]
            fen = np.hanning(len(signal_w))
            signal_w = signal_w * fen
            STFT[:, j] = np.fft.rfft(signal_w, self.nfft)
        if pad:
            STFT = np.pad(STFT, ([0, 0], [0, self.ntimes - current_nb_trames]))
        return STFT

    def stft_to_mel(self, STFT):
        """

        Parameters
        ----------
        STFT

        Returns
        -------

        """
        STFT_mel_amp = np.dot(self.mel_fbank, np.abs(STFT))
        STFT_mel_amp = np.log10(STFT_mel_amp + 1e-6)
        STFT_mel_if = np.dot(self.mel_fbank, self.get_IF_from_phase(np.angle(STFT)))
        STFT_mel = np.stack((STFT_mel_amp, STFT_mel_if))
        return STFT_mel

    def rebuild_signal(self, STFT):
        """

        Parameters
        ----------
        STFT

        Returns
        -------

        """
        N = self.hop * STFT.shape[1] + self.win_length
        fen = np.hanning(self.win_length)  # définition de la fenetre d'analyse
        ws = fen
        # définition de la fenêtre de synthèse
        y = np.zeros((N))  # signal de synthèse
        # boucle sur les trames
        for u in np.arange(0, STFT.shape[1]).reshape(-1):
            deb = u * self.hop  # début de trame
            fin = deb + self.win_length  # fin de trame
            y[deb:fin] = y[deb:fin] + (np.real(np.fft.irfft(STFT[:, u]) * ws))
        return y

    def mel_to_stft_griffin(self, STFT_mel_amp):
        """

        Parameters
        ----------
        STFT_mel_amp

        Returns
        -------

        """
        STFT_amp = np.dot(self.inverse_fbank, STFT_mel_amp)
        return STFT_amp

    def mel_to_stft_IF(self, STFT_mel):
        """

        Parameters
        ----------
        STFT_mel

        Returns
        -------

        """
        STFT_amp = np.dot(self.inverse_fbank, STFT_mel[0, :])
        STFT_IF = np.dot(self.inverse_fbank, STFT_mel[1, :])
        return STFT_amp, STFT_IF

    def griffin_phase(self, STFT_amp):
        """

        Parameters
        ----------
        STFT_amp

        Returns
        -------

        """
        phase_init = self.griffin_phase_init
        nb_iterations = self.griffin_nb_iterations
        required_loss = self.griffin_required_loss

        if required_loss:
            # to show the evolution of the loss (MSE between input STFT
            # amplitude and estimated STFT amplitude) over the iterations
            loss = np.empty(nb_iterations)

        if phase_init is None:
            STFT_hat = STFT_amp * np.exp(
                1j * np.random.rand(STFT_amp.shape[0], STFT_amp.shape[1]) * np.pi / 2
            )
        else:
            STFT_hat = STFT_amp * np.exp(1j * phase_init)

        for ind_iteration in range(nb_iterations):
            x_recovered = self.rebuild_signal(STFT_hat)

            STFT_temp = self.get_stft(x_recovered, pad=False)
            STFT_hat = STFT_amp * np.exp(1j * np.angle(STFT_temp))
            if required_loss:
                loss[ind_iteration] = np.linalg.norm(np.abs(STFT_temp) - STFT_amp)

        if required_loss:
            return np.angle(STFT_hat), loss
        else:
            return np.angle(STFT_hat)
